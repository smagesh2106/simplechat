/*
 * Swagger User store
 *
 * This is a sample server User server.  You can find out more about     Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).      For this sample, you can use the api key `special-key` to test the authorization     filters.
 *
 */

//package swagger
package api

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/rs/cors"
)

func validateGoogle(r *http.Request, token string) bool {
	fmt.Println("Invoking Google API")
	url := "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=" + token
	method := "POST"
	client := &http.Client{}

	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		fmt.Println(err)
	}
	res, err := client.Do(req)
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)

	fmt.Println(string(body))
	if err != nil || res.StatusCode >= 400 {
		fmt.Println("invalid token")
		return false
	} else {
		fmt.Println("valid token")
		return true
	}
}

func validateLinkedIn(r *http.Request, token string) bool {
	fmt.Println("Invoking LinkedIn API")
	url := "https://api.linkedin.com/v2/me"
	method := "GET"

	client := &http.Client{}
	req, err := http.NewRequest(method, url, nil)

	if err != nil {
		fmt.Println(err)
	}
	req.Header.Add("Authorization", token)
	res, err := client.Do(req)
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)

	fmt.Println(string(body))
	if err != nil || res.StatusCode == 401 {
		fmt.Println("invalid token")
		return false
	} else {
		fmt.Println("valid token")
		return true
	}
}

func Validator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cor := cors.New(cors.Options{
			AllowedOrigins:   []string{"*"},
			AllowedMethods:   []string{"POST", "GET", "OPTIONS", "PUT"},
			AllowedHeaders:   []string{"Access-Control-Allow-Credentials", "Accept", "Accept-Language", "Content-Type", "Content-Length", "Accept-Encoding", "Authorization", "Access-Control-Allow-Origin", "X-CSRF-Token", "Origin"},
			AllowCredentials: true,
			Debug:            true,
		})
		//<FIXME> perform token, auth validations here.
		//allowedHeaders := "Accept, Content-Type, Content-Length, Accept-Encoding, Authorization,X-CSRF-Token, Origin"
		log.Println("middleware -1 executed")
		log.Printf("origin %v", r.Header.Get("Origin"))
		next = cor.Handler(next)
		if r.URL.Path == "/oauth/callback" || r.URL.Path == "/v1/categories" || r.URL.Path == "/v1/user" || r.URL.Path == "/v1/user/auth" {
			log.Printf("Skipping auth check for path %v", r.URL.Path)
			next.ServeHTTP(w, r)
		} else {
			log.Printf("Checking authorization for path: %v", r.URL.Path)
			var validToken bool
			reqToken := r.Header.Get("Authorization")
			//fmt.Printf("Auth Header: %v", reqToken)
			if reqToken == "" {
				fmt.Println("Please provide a token")
				w.WriteHeader(http.StatusBadRequest)
				return
			}
			splitToken := strings.Split(reqToken, "Bearer ")
			if len(splitToken) != 2 {
				fmt.Println("Bearer token not in proper format")
				w.WriteHeader(http.StatusBadRequest)
				return
			}
			parsedToken := strings.TrimSpace(splitToken[1])
			fmt.Println("Token %v", parsedToken)
			/*
				if (len(reqToken) < 325) {
					validToken = validateGoogle(r, parsedToken)
				} else {
					validToken = validateLinkedIn(r, reqToken)
				}*/
			if ValidateSessionToken(parsedToken) {
				fmt.Println("Bearer token not in proper format")
				w.WriteHeader(http.StatusUnauthorized)
				return
			}
			userContext, _ := GetUserSessionInfoFromSessionToken(parsedToken)
			r = r.WithContext(context.WithValue(r.Context(), "userContext", userContext))

			next = cor.Handler(next)
			if validToken {
				next.ServeHTTP(w, r)
			} else {
				next.ServeHTTP(w, r)
			}
		}
	})
}

func Logger(inner http.Handler, name string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Println("middleware -2 executed")
		allowedHeaders := "Accept, Content-Type, Content-Length, Accept-Encoding, Authorization,X-CSRF-Token,Origin"
		start := time.Now()
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
		w.Header().Set("Access-Control-Allow-Headers", allowedHeaders)
		inner.ServeHTTP(w, r)
		log.Printf(
			"%s %s %s %s",
			r.Method,
			r.RequestURI,
			name,
			time.Since(start),
		)
	})
}

func setUserContext(r *http.Request, sessionToken string) error {
	userContext, err := GetUserSessionInfoFromSessionToken(sessionToken)
	if err != nil {
		log.Println("err in setUserContext, err: ", err)
		return err
	}
	fmt.Println("userContext", userContext)
	r = r.WithContext(context.WithValue(r.Context(), "userContext", userContext))
	return nil
}

func GetUserSession(ctx context.Context) (*UserSession, bool) {
	val, ok := ctx.Value("userContext").(*UserSession)
	return val, ok
}
